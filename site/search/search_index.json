{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Docs","text":"Solvers Collection of numerical solvers Utilities Helper functions and utilities Network Components Neural network layers and components Trackers Data tracking and logging tools Datasets Dataset handling and processing LSM Utilities Utilities specific to Liquid State Machines neuronModels Collection of neuron model state representations and right-hand side functors."},{"location":"datasets/","title":"Datasets","text":"<p>Dataset handling and processing</p>"},{"location":"datasets/#types","title":"Types","text":"Name Description MNIST Minimal MNIST dataset loader supporting sorting and splitting utilities."},{"location":"datasets/#functions","title":"Functions","text":"Name Description swap_endian Swaps byte order for 32-bit integers (big-endian &lt;-&gt; little-endian)."},{"location":"datasets/#function-details","title":"Function Details","text":""},{"location":"datasets/#swap_endian","title":"swap_endian","text":"<p>inline uint32_t swap_endian(uint32_t val)</p> <p>Swaps byte order for 32-bit integers (big-endian &lt;-&gt; little-endian).</p> <code>val</code> Value to swap. Return Reordered integer."},{"location":"datasets/MNIST/","title":"MNIST","text":"<p>template &lt;typename T&gt; class MNIST</p> <p>Minimal MNIST dataset loader supporting sorting and splitting utilities.</p> <code>T</code> Numeric type used to store pixel values."},{"location":"lsm_utils/","title":"LSM Utilities","text":"<p>Utilities specific to Liquid State Machines</p>"},{"location":"lsm_utils/#types","title":"Types","text":"Name Description SelectionMode Defines the selection mode for the random sampling. networkBuilder Generates reservoir connectivity, weights, and metadata for the LSM."},{"location":"lsm_utils/#functions","title":"Functions","text":"Name Description loadLSM Loads six Thrust device vectors from a binary configuration file. mapInputToLSM Maps input channels to reservoir neurons using random selection. saveLSM Saves six Thrust device vectors to a binary configuration file."},{"location":"lsm_utils/#function-details","title":"Function Details","text":""},{"location":"lsm_utils/#loadlsm","title":"loadLSM","text":"<p>bool loadLSM( string fileName, thrust::device_vector&lt;float&gt;&amp; ILSM_Xpre, thrust::device_vector&lt;float&gt;&amp; ILSM_Xpost, thrust::device_vector&lt;float&gt;&amp; ILSM_W, thrust::device_vector&lt;float&gt;&amp; LSM_Xpre, thrust::device_vector&lt;float&gt;&amp; LSM_Xpost, thrust::device_vector&lt;float&gt;&amp; LSM_W )</p> <p>Loads six Thrust device vectors from a binary configuration file.</p> <code>fileName</code> The path to the file. <code>ILSM_Xpre</code> Output vector 1 (modified by reference). <code>ILSM_Xpost</code> Output vector 2 (modified by reference). <code>ILSM_W</code> Output vector 3 (modified by reference). <code>LSM_Xpre</code> Output vector 4 (modified by reference). <code>LSM_Xpost</code> Output vector 5 (modified by reference). <code>LSM_W</code> Output vector 6 (modified by reference). Return true if successful, false otherwise."},{"location":"lsm_utils/#mapinputtolsm","title":"mapInputToLSM","text":"<p>bool mapInputToLSM( int iN, const std::vector&lt;int&gt;&amp; indices_h, SelectionMode mode, thrust::device_vector&lt;int&gt;&amp; X_d, thrust::device_vector&lt;int&gt;&amp; Xn_d)</p> <p>Maps input channels to reservoir neurons using random selection.</p> <code>iN</code> Number of input connections to generate. <code>indices_h</code> Host vector of candidate neuron indices. <code>mode</code> SelectionMode specifying replacement behavior. <code>X_d</code> Output presynaptic indices (0..iN-1). <code>Xn_d</code> Output postsynaptic indices sampled from indices_h. Return true on success, false when constraints are violated."},{"location":"lsm_utils/#savelsm","title":"saveLSM","text":"<p>bool saveLSM( string fileName, thrust::device_vector&lt;float&gt; ILSM_Xpre, thrust::device_vector&lt;float&gt; ILSM_Xpost, thrust::device_vector&lt;float&gt; ILSM_W, thrust::device_vector&lt;float&gt; LSM_Xpre, thrust::device_vector&lt;float&gt; LSM_Xpost, thrust::device_vector&lt;float&gt; LSM_W )</p> <p>Saves six Thrust device vectors to a binary configuration file.</p> <code>fileName</code> The path to the file. <code>ILSM_Xpre</code> Input vector 1. <code>ILSM_Xpost</code> Input vector 2. <code>ILSM_W</code> Input vector 3. <code>LSM_Xpre</code> Input vector 4. <code>LSM_Xpost</code> Input vector 5. <code>LSM_W</code> Input vector 6. Return true if successful, false otherwise."},{"location":"lsm_utils/SelectionMode/","title":"SelectionMode","text":"<p>enum class SelectionMode</p> <p>Defines the selection mode for the random sampling.</p> <p>Selection strategy for mapping inputs to reservoir neurons.</p> REPEATING The same element from the indices vector can be selected multiple times (sampling with replacement). NON_REPEATING Each element from the indices vector can be selected only once (sampling without replacement)."},{"location":"lsm_utils/networkBuilder/","title":"networkBuilder","text":"<p>class networkBuilder</p> <p>Generates reservoir connectivity, weights, and metadata for the LSM.</p>"},{"location":"lsm_utils/networkBuilder/#functions","title":"Functions","text":"Name Description networkBuilder Constructs a network with randomized excitatory/inhibitory distribution and geometry. build Builds connectivity, weights, and delays based on geometry. normalize_weights Normalizes weights by the number of incoming connections per target neuron. compute_EI_indices Populates lists of excitatory and inhibitory neuron indices."},{"location":"lsm_utils/networkBuilder/#function-details","title":"Function Details","text":""},{"location":"lsm_utils/networkBuilder/#build","title":"build","text":"<p>void build( const Eigen::Vector3i&amp; resSize, const Eigen::Matrix2f&amp; w, float r0, const Eigen::Matrix2f&amp; k0, float f_inhibit, float tau, bool /*show*/, const std::vector&lt;int&gt;&amp; UC, const Eigen::Vector3i&amp; UC_dims, bool _normalize )</p> <p>Builds connectivity, weights, and delays based on geometry.</p> <code>resSize</code> Reservoir dimensions. <code>w</code> Weight matrix for E/I combinations. <code>r0</code> Spatial decay radius. <code>k0</code> Connection probability coefficients. <code>f_inhibit</code> Fraction of inhibitory neurons. <code>tau</code> Synaptic delay scaling. <code>show</code> Unused flag kept for compatibility. <code>UC</code> Optional user-defined pattern. <code>UC_dims</code> Dimensions of the user pattern. <code>_normalize</code> Whether to normalize outgoing weights per neuron."},{"location":"lsm_utils/networkBuilder/#compute_ei_indices","title":"compute_EI_indices","text":"<p>void compute_EI_indices()</p> <p>Populates lists of excitatory and inhibitory neuron indices.</p>"},{"location":"lsm_utils/networkBuilder/#networkbuilder_1","title":"networkBuilder","text":"<p>networkBuilder( const Eigen::Vector3i&amp; resSize = Eigen::Vector3i(3, 3, 5), const Eigen::Matrix2f&amp; w = (Eigen::Matrix2f() &lt;&lt; 3, 6, -2, -2).finished(), float r0 = 2.0f, const Eigen::Matrix2f&amp; k0 = (Eigen::Matrix2f() &lt;&lt; 0.45f, 0.3f, 0.6f, 0.15f).finished(), float f_inhibit = 0.2f, float tau = 1e-3f, bool show = false,  // ignored const std::vector&lt;int&gt;&amp; UC = {}, const Eigen::Vector3i&amp; UC_dims = Eigen::Vector3i(0, 0, 0), bool _normalize = true )</p> <p>Constructs a network with randomized excitatory/inhibitory distribution and geometry.</p> <code>resSize</code> Reservoir dimensions. <code>w</code> Weight matrix for E/I combinations. <code>r0</code> Spatial decay radius. <code>k0</code> Connection probability coefficients. <code>f_inhibit</code> Fraction of inhibitory neurons. <code>tau</code> Synaptic delay scaling. <code>show</code> Deprecated flag (ignored). <code>UC</code> Optional user-defined pattern. <code>UC_dims</code> Dimensions of the user pattern. <code>_normalize</code> Whether to normalize outgoing weights per neuron."},{"location":"lsm_utils/networkBuilder/#normalize_weights","title":"normalize_weights","text":"<p>std::vector&lt;float&gt; normalize_weights( const std::vector&lt;int&gt;&amp; X, const std::vector&lt;int&gt;&amp; Xn, const std::vector&lt;float&gt;&amp; W)</p> <p>Normalizes weights by the number of incoming connections per target neuron.</p> <code>X</code> Source indices for each connection. <code>Xn</code> Destination indices for each connection. <code>W</code> Unnormalized weights. Return Weight vector scaled per destination neuron."},{"location":"network/","title":"Network Components","text":"<p>Neural network layers and components</p> Signal propagation Components for propagating signals through network"},{"location":"network/#types","title":"Types","text":"Name Description genericLayer Generic layer wrapper holding neuron states and inputs."},{"location":"network/genericLayer/","title":"genericLayer","text":"<p>template&lt;typename StateTypes&gt; // e.g. thrust::tuple&lt;float,float,float&gt; class genericLayer</p> <p>Generic layer wrapper holding neuron states and inputs.</p> <code>StateTypes</code> Thrust tuple describing the per-neuron state variables."},{"location":"network/genericLayer/#functions","title":"Functions","text":"Name Description make_state_tuple Helper to construct the tuple of state vectors on the device. genericLayer Constructs a layer with the given neuron count. size Returns the number of neurons in the layer. state_vec Access a specific state vector by index. state_vec Access a specific state vector by index (const overload). make_zip_begin Create a zip iterator over all state vectors (mutable). make_zip_end Create a zip iterator over all state vectors (mutable) - end. make_zip_begin Create a zip iterator over all state vectors (const). make_zip_end Create a zip iterator over all state vectors (const) - end. full_zip_begin Create a zip iterator over state and input (mutable). full_zip_end Create a zip iterator over state and input (mutable) - end. step Advance the layer state by one integration step using RK4. input Access the input buffer for modification. input Access the input buffer (read-only). make_begin_tuple Build a tuple of begin iterators for all state vectors. make_end_tuple Build a tuple of end iterators for all state vectors. make_cbegin_tuple Build a tuple of const begin iterators for all state vectors. make_cend_tuple Build a tuple of const end iterators for all state vectors."},{"location":"network/genericLayer/#function-details","title":"Function Details","text":""},{"location":"network/genericLayer/#full_zip_begin","title":"full_zip_begin","text":"<p>auto full_zip_begin()</p> <p>Create a zip iterator over state and input (mutable).</p> <p>The iterator dereferences to a tuple of (state tuple iterator, input value).</p> Return Iterator to the beginning of the zipped state+input range."},{"location":"network/genericLayer/#full_zip_end","title":"full_zip_end","text":"<p>auto full_zip_end()</p> <p>Create a zip iterator over state and input (mutable) - end.</p> Return Iterator to the end of the zipped state+input range."},{"location":"network/genericLayer/#genericlayer_1","title":"genericLayer","text":"<p>explicit genericLayer(size_t N)</p> <p>Constructs a layer with the given neuron count.</p> <code>N</code> Number of neurons/states to allocate."},{"location":"network/genericLayer/#input","title":"input","text":"<p>thrust::device_vector&lt;float&gt;&amp; input() noexcept</p> <p>Access the input buffer for modification.</p> Return Reference to the device vector storing input currents. <p>const thrust::device_vector&lt;float&gt;&amp; input() const noexcept</p> <p>Access the input buffer (read-only).</p> Return Const reference to the device vector storing input currents."},{"location":"network/genericLayer/#make_begin_tuple","title":"make_begin_tuple","text":"<p>template&lt;size_t... I&gt; auto make_begin_tuple(std::index_sequence&lt;I...&gt;)</p> <p>Build a tuple of begin iterators for all state vectors.</p> <code>I</code> Index pack over the elements of StateTypes. Return Thrust tuple of begin iterators."},{"location":"network/genericLayer/#make_cbegin_tuple","title":"make_cbegin_tuple","text":"<p>template&lt;size_t... I&gt; auto make_cbegin_tuple(std::index_sequence&lt;I...&gt;) const</p> <p>Build a tuple of const begin iterators for all state vectors.</p> <code>I</code> Index pack over the elements of StateTypes. Return Thrust tuple of const begin iterators."},{"location":"network/genericLayer/#make_cend_tuple","title":"make_cend_tuple","text":"<p>template&lt;size_t... I&gt; auto make_cend_tuple(std::index_sequence&lt;I...&gt;) const</p> <p>Build a tuple of const end iterators for all state vectors.</p> <code>I</code> Index pack over the elements of StateTypes. Return Thrust tuple of const end iterators."},{"location":"network/genericLayer/#make_end_tuple","title":"make_end_tuple","text":"<p>template&lt;size_t... I&gt; auto make_end_tuple(std::index_sequence&lt;I...&gt;)</p> <p>Build a tuple of end iterators for all state vectors.</p> <code>I</code> Index pack over the elements of StateTypes. Return Thrust tuple of end iterators."},{"location":"network/genericLayer/#make_state_tuple","title":"make_state_tuple","text":"<p>template&lt;size_t... I&gt; static auto make_state_tuple(size_t N, std::index_sequence&lt;I...&gt;)</p> <p>Helper to construct the tuple of state vectors on the device.</p> <p>For each element type in StateTypes, creates a corresponding thrust::device_vector of size <code>N</code> initialized to zero.</p> <code>I</code> Index pack over the elements of StateTypes. <code>N</code> Number of elements in each state vector. Return Tuple of device vectors matching StateTypes."},{"location":"network/genericLayer/#make_zip_begin","title":"make_zip_begin","text":"<p>auto make_zip_begin()</p> <p>Create a zip iterator over all state vectors (mutable).</p> <p>Each element of the iterator is a thrust::tuple of references to the components of the neuron state.</p> Return Iterator to the beginning of the zipped state range. <p>auto make_zip_begin() const</p> <p>Create a zip iterator over all state vectors (const).</p> Return Const iterator to the beginning of the zipped state range."},{"location":"network/genericLayer/#make_zip_end","title":"make_zip_end","text":"<p>auto make_zip_end()</p> <p>Create a zip iterator over all state vectors (mutable) - end.</p> Return Iterator to the end of the zipped state range. <p>auto make_zip_end() const</p> <p>Create a zip iterator over all state vectors (const) - end.</p> Return Const iterator to the end of the zipped state range."},{"location":"network/genericLayer/#size","title":"size","text":"<p>size_t size() const noexcept</p> <p>Returns the number of neurons in the layer.</p>"},{"location":"network/genericLayer/#state_vec","title":"state_vec","text":"<p>template&lt;size_t I&gt; auto&amp; state_vec() noexcept</p> <p>Access a specific state vector by index.</p> <code>I</code> Index of the state component in the StateTypes tuple. Return Reference to the corresponding device vector. <p>template&lt;size_t I&gt; const auto&amp; state_vec() const noexcept</p> <p>Access a specific state vector by index (const overload).</p> <code>I</code> Index of the state component in the StateTypes tuple. Return Const reference to the corresponding device vector."},{"location":"network/genericLayer/#step","title":"step","text":"<p>template&lt;typename RHS_Functor&gt; void step(const RHS_Functor&amp; rhs, float t, float dt, cudaStream_t stream = 0)</p> <p>Advance the layer state by one integration step using RK4.</p> <p>Applies the provided RHS functor on all neurons in parallel using Thrust on the given CUDA stream.</p> <code>RHS_Functor</code> Functor type providing the right-hand side of the ODE.                     It must be callable from device code. See Solvers <code>rhs</code> Right-hand side functor. <code>t</code> Current time. <code>dt</code> Time step. <code>stream</code> CUDA stream to execute the operation on (default 0)."},{"location":"network/propagators/","title":"Signal propagation","text":"<p>Components for propagating signals through network</p> Sparse Propagators Components for sparse signal propagation Deprecated Propagators Outdated signal propagation components"},{"location":"network/propagators/deprecated/","title":"Deprecated Propagators","text":"<p>Outdated signal propagation components</p>"},{"location":"network/propagators/deprecated/#types","title":"Types","text":"Name Description InputBehavior Determines how computed inputs are combined with existing buffers."},{"location":"network/propagators/deprecated/#functions","title":"Functions","text":"Name Description dense_p Dense matrix propagation using cuBLAS sgemv. forward_p One-to-one propagation (diagonal weight vector). sparse_p Sparse propagation using explicit edge lists."},{"location":"network/propagators/deprecated/#function-details","title":"Function Details","text":""},{"location":"network/propagators/deprecated/#dense_p","title":"dense_p","text":"<p>template&lt;size_t stateVar, typename PreStateTypes, typename PostStateTypes&gt; void dense_p( genericLayer&lt;PreStateTypes&gt;&amp; preLayer, genericLayer&lt;PostStateTypes&gt;&amp; postLayer, const thrust::device_vector&lt;float&gt;&amp; W_flat, // column-major (N_post \u00d7 N_pre) cublasHandle_t handle, InputBehavior behavior = INPUT_OVERRIDE, cudaStream_t stream = 0 )</p> <p>Dense matrix propagation using cuBLAS sgemv.</p> <code>stateVar</code> Index of the presynaptic state variable to propagate. <code>PreStateTypes</code> Tuple type for the presynaptic layer. <code>PostStateTypes</code> Tuple type for the postsynaptic layer. <code>preLayer</code> Source layer. <code>postLayer</code> Destination layer. <code>W_flat</code> Column-major weight matrix (N_post x N_pre). <code>handle</code> cuBLAS handle. <code>behavior</code> Input accumulation behavior. <code>stream</code> CUDA stream for execution."},{"location":"network/propagators/deprecated/#forward_p","title":"forward_p","text":"<p>template&lt;size_t stateVar, typename PreStateTypes, typename PostStateTypes&gt; void forward_p( genericLayer&lt;PreStateTypes&gt;&amp; preLayer, genericLayer&lt;PostStateTypes&gt;&amp; postLayer, const thrust::device_vector&lt;float&gt;&amp; W, InputBehavior behavior = INPUT_OVERRIDE, cudaStream_t stream = 0 )</p> <p>One-to-one propagation (diagonal weight vector).</p> <code>stateVar</code> Index of the presynaptic state variable to propagate. <code>PreStateTypes</code> Tuple type for the presynaptic layer. <code>PostStateTypes</code> Tuple type for the postsynaptic layer. <code>preLayer</code> Source layer. <code>postLayer</code> Destination layer. <code>W</code> Weight vector aligned with neuron indices. <code>behavior</code> Input accumulation behavior. <code>stream</code> CUDA stream for execution."},{"location":"network/propagators/deprecated/#sparse_p","title":"sparse_p","text":"<p>template&lt;size_t stateVar, typename PreStateTypes, typename PostStateTypes&gt; void sparse_p( genericLayer&lt;PreStateTypes&gt;&amp; preLayer, genericLayer&lt;PostStateTypes&gt;&amp; postLayer, const thrust::device_vector&lt;int&gt;&amp; X,    // presynaptic indices const thrust::device_vector&lt;int&gt;&amp; Xn,   // postsynaptic indices const thrust::device_vector&lt;float&gt;&amp; W,  // weights InputBehavior behavior = INPUT_OVERRIDE, cudaStream_t stream = 0 )</p> <p>Sparse propagation using explicit edge lists.</p> <code>stateVar</code> Index of the presynaptic state variable to propagate. <code>PreStateTypes</code> Tuple type for the presynaptic layer. <code>PostStateTypes</code> Tuple type for the postsynaptic layer. <code>preLayer</code> Source layer. <code>postLayer</code> Destination layer. <code>X</code> Presynaptic indices. <code>Xn</code> Postsynaptic indices. <code>W</code> Connection weights. <code>behavior</code> Input accumulation behavior. <code>stream</code> CUDA stream for execution."},{"location":"network/propagators/deprecated/InputBehavior/","title":"InputBehavior","text":"<p>enum class InputBehavior : uint8_t</p> <p>Determines how computed inputs are combined with existing buffers.</p>"},{"location":"network/propagators/sparse_propagators/","title":"Sparse Propagators","text":"<p>Components for sparse signal propagation</p>"},{"location":"network/propagators/sparse_propagators/#types","title":"Types","text":"Name Description InputBehavior Defines how SpMV results are merged into the destination input buffer. SparsePropagator RAII wrapper for cuSPARSE SpMV propagation with prebuilt CSR matrices."},{"location":"network/propagators/sparse_propagators/InputBehavior/","title":"InputBehavior","text":"<p>enum class InputBehavior : uint8_t</p> <p>Defines how SpMV results are merged into the destination input buffer.</p>"},{"location":"network/propagators/sparse_propagators/SparsePropagator/","title":"SparsePropagator","text":"<p>class SparsePropagator</p> <p>RAII wrapper for cuSPARSE SpMV propagation with prebuilt CSR matrices.</p>"},{"location":"network/propagators/sparse_propagators/SparsePropagator/#functions","title":"Functions","text":"Name Description init Initializes the cuSPARSE handle if it has not been created. destroy Releases allocated matrices and destroys the cuSPARSE handle. buildCSR Build CSR from (Xn, X, W) triplets. propagate Propagate preLayer state -&gt; postLayer input using a named CSR."},{"location":"network/propagators/sparse_propagators/SparsePropagator/#function-details","title":"Function Details","text":""},{"location":"network/propagators/sparse_propagators/SparsePropagator/#buildcsr","title":"buildCSR","text":"<p>void buildCSR(const thrust::device_vector&lt;int&gt;&amp; X, const thrust::device_vector&lt;int&gt;&amp; Xn, const thrust::device_vector&lt;float&gt;&amp; W, const std::string&amp; name, int num_pre, int num_post, cudaStream_t stream = 0)</p> <p>Build CSR from (Xn, X, W) triplets. Build CSR from (Xn, X, W) triplets.</p> <code>X</code> Presynaptic indices. <code>Xn</code> Postsynaptic indices. <code>W</code> Connection weights. <code>name</code> Key used to reference the built matrix. <code>num_pre</code> Number of presynaptic neurons. <code>num_post</code> Number of postsynaptic neurons. <code>stream</code> CUDA stream for preprocessing."},{"location":"network/propagators/sparse_propagators/SparsePropagator/#destroy","title":"destroy","text":"<p>void destroy()</p> <p>Releases allocated matrices and destroys the cuSPARSE handle.</p>"},{"location":"network/propagators/sparse_propagators/SparsePropagator/#init","title":"init","text":"<p>void init()</p> <p>Initializes the cuSPARSE handle if it has not been created.</p>"},{"location":"network/propagators/sparse_propagators/SparsePropagator/#propagate","title":"propagate","text":"<p>template&lt;size_t stateVar, typename PreStateTypes, typename PostStateTypes&gt; void propagate(genericLayer&lt;PreStateTypes&gt;&amp; preLayer, genericLayer&lt;PostStateTypes&gt;&amp; postLayer, const std::string&amp; name, InputBehavior behavior = InputBehavior::INPUT_OVERRIDE, cudaStream_t stream = 0)</p> <p>Propagate preLayer state -&gt; postLayer input using a named CSR. Propagate preLayer state -&gt; postLayer input using a named CSR.</p> <code>stateVar</code> Index of the presynaptic state variable to propagate. <code>PreStateTypes</code> Tuple type for the presynaptic layer. <code>PostStateTypes</code> Tuple type for the postsynaptic layer. <code>preLayer</code> Source layer. <code>postLayer</code> Destination layer. <code>name</code> Key of the CSR matrix to use. <code>behavior</code> Input accumulation behavior. <code>stream</code> CUDA stream for the SpMV call."},{"location":"neuronModels/","title":"neuronModels","text":"<p>Collection of neuron model state representations and right-hand side functors.</p>"},{"location":"neuronModels/#types","title":"Types","text":"Name Description FHN_RHS Right-hand side functor for the FitzHugh\u2013Nagumo neuron dynamics. MemTunnerNeuron_RHS Right-hand side functor for the memristor tunneling neuron model."},{"location":"neuronModels/#type-aliases","title":"Type Aliases","text":"Name Description FHN State tuple for the FitzHugh\u2013Nagumo model (u, v). MemTunnerNeuron State tuple for the memristor-based tunneling neuron (Vc, XSV)."},{"location":"neuronModels/#type-alias-details","title":"Type Alias Details","text":""},{"location":"neuronModels/#fhn","title":"FHN","text":"<p>using FHN = StateTuple&lt;float, float&gt;</p> <p>State tuple for the FitzHugh\u2013Nagumo model (u, v).</p>"},{"location":"neuronModels/#memtunnerneuron","title":"MemTunnerNeuron","text":"<p>using MemTunnerNeuron = StateTuple&lt;float, float&gt;</p> <p>State tuple for the memristor-based tunneling neuron (Vc, XSV).</p>"},{"location":"neuronModels/FHN_RHS/","title":"FHN_RHS","text":"<p>struct FHN_RHS</p> <p>Right-hand side functor for the FitzHugh\u2013Nagumo neuron dynamics.</p> See FHN"},{"location":"neuronModels/MemTunnerNeuron_RHS/","title":"MemTunnerNeuron_RHS","text":"<p>struct MemTunnerNeuron_RHS</p> <p>Right-hand side functor for the memristor tunneling neuron model.</p> See MemTunnerNeuron"},{"location":"neuronModels/MemTunnerNeuron_RHS/#operators","title":"Operators","text":"Name Description operator() Evaluates time derivatives for the memristor neuron."},{"location":"neuronModels/MemTunnerNeuron_RHS/#functions","title":"Functions","text":"Name Description GI403 Computes the diode/tunnel current contribution. AND_TS Calculates memristor branch current and state derivative."},{"location":"neuronModels/MemTunnerNeuron_RHS/#operator-details","title":"Operator Details","text":""},{"location":"neuronModels/MemTunnerNeuron_RHS/#operator","title":"operator()","text":"<p>host device inline void operator()(const MemTunnerNeuron&amp; state_in, MemTunnerNeuron&amp; ddt_out, float I_syn, float t) const</p> <p>Evaluates time derivatives for the memristor neuron.</p> <code>state_in</code> Current state tuple (Vc, XSV). <code>ddt_out</code> Output derivatives. <code>I_syn</code> Input synaptic current. <code>t</code> Current simulation time (unused)."},{"location":"neuronModels/MemTunnerNeuron_RHS/#function-details","title":"Function Details","text":""},{"location":"neuronModels/MemTunnerNeuron_RHS/#and_ts","title":"AND_TS","text":"<p>host device inline MemTunnerNeuron AND_TS(float V1, float V2) const</p> <p>Calculates memristor branch current and state derivative.</p> <code>V1</code> Membrane voltage. <code>V2</code> State variable representing conductance fraction. Return Pair of memristor current and state change."},{"location":"neuronModels/MemTunnerNeuron_RHS/#gi403","title":"GI403","text":"<p>host device inline float GI403(float e) const</p> <p>Computes the diode/tunnel current contribution.</p> <code>e</code> Diode voltage. Return Combined current through the device."},{"location":"solvers/","title":"Solvers","text":"<p>Collection of numerical solvers</p>"},{"location":"solvers/#types","title":"Types","text":"Name Description RK4_Step_Functor Functor executing a single Runge\u2013Kutta 4 integration step."},{"location":"solvers/#functions","title":"Functions","text":"Name Description apply_k_step Component-wise RK4 update for a single k-step."},{"location":"solvers/#function-details","title":"Function Details","text":""},{"location":"solvers/#apply_k_step","title":"apply_k_step","text":"<p>template &lt;size_t I, typename State&gt; host device inline void apply_k_step(State&amp; next_state, const State&amp; current_state, const State&amp; k_step, float factor)</p> <p>Component-wise RK4 update for a single k-step.</p> <code>I</code> Current tuple index (compile-time recursion). <code>State</code> Tuple type storing state variables. <code>next_state</code> Output state receiving the update. <code>current_state</code> State at the beginning of the step. <code>k_step</code> Derivative estimate for the current stage. <code>factor</code> Scaling factor applied to k_step."},{"location":"solvers/RK4_Step_Functor/","title":"RK4_Step_Functor","text":"<p>template&lt;typename RHS, typename State&gt; struct RK4_Step_Functor</p> <p>Functor executing a single Runge\u2013Kutta 4 integration step.</p> <code>RHS</code> Right-hand-side functor computing derivatives. <code>State</code> Tuple type representing the neuron state."},{"location":"solvers/RK4_Step_Functor/#operators","title":"Operators","text":"Name Description operator() Applies RK4 integration to a zipped state/input tuple."},{"location":"solvers/RK4_Step_Functor/#functions","title":"Functions","text":"Name Description RK4_Step_Functor Constructs the functor with simulation parameters."},{"location":"solvers/RK4_Step_Functor/#operator-details","title":"Operator Details","text":""},{"location":"solvers/RK4_Step_Functor/#operator","title":"operator()","text":"<p>template&lt;typename Tuple&gt; host device /** * Applies RK4 integration to a zipped state/input tuple. * @param t_zip Tuple containing the current state and input value. */ void operator()(Tuple t_zip) const</p> <p>Applies RK4 integration to a zipped state/input tuple.</p> <code>t_zip</code> Tuple containing the current state and input value."},{"location":"solvers/RK4_Step_Functor/#function-details","title":"Function Details","text":""},{"location":"solvers/RK4_Step_Functor/#rk4_step_functor_1","title":"RK4_Step_Functor","text":"<p>RK4_Step_Functor(float t, float dt, RHS rhs)</p> <p>Constructs the functor with simulation parameters.</p> <code>t</code> Current simulation time. <code>dt</code> Time step size. <code>rhs</code> Right-hand-side functor instance."},{"location":"trackers/","title":"Trackers","text":"<p>Data tracking and logging tools</p>"},{"location":"trackers/#types","title":"Types","text":"Name Description CounterBehavior Defines the type of threshold crossing to count. crossingsCounter Counts threshold crossings for a specific state variable in a layer. layerLogger Asynchronous logger that records layer states and inputs to CSV files. layerLogger_sync Synchronous logger optionally buffering data before writing to CSV."},{"location":"trackers/CounterBehavior/","title":"CounterBehavior","text":"<p>enum class CounterBehavior : uint8_t</p> <p>Defines the type of threshold crossing to count.</p>"},{"location":"trackers/crossingsCounter/","title":"crossingsCounter","text":"<p>template&lt;typename Layer, size_t I&gt; class crossingsCounter</p> <p>Counts threshold crossings for a specific state variable in a layer.</p> <code>Layer</code> Layer type exposing state_tuple_type. <code>I</code> Index of the state variable to monitor."},{"location":"trackers/crossingsCounter/#functions","title":"Functions","text":"Name Description crossingsCounter Constructor for the crossingsCounter. count Performs the crossing count for the current step. reset Resets the crossing counts to zero. destroy Cleans up device memory."},{"location":"trackers/crossingsCounter/#function-details","title":"Function Details","text":""},{"location":"trackers/crossingsCounter/#count","title":"count","text":"<p>void count(int step)</p> <p>Performs the crossing count for the current step.</p> <code>step</code> The current simulation step number."},{"location":"trackers/crossingsCounter/#crossingscounter_1","title":"crossingsCounter","text":"<p>crossingsCounter(Layer&amp; layer, state_value_type threshold, CounterBehavior behavior = CounterBehavior::BELOW_THR)</p> <p>Constructor for the crossingsCounter.</p> <code>layer</code> The reference to the simulation layer. <code>threshold</code> The value a state must cross to be counted. <code>behavior</code> The type of crossing to count (BELOW_THR, ABOVE_THR, BIDIRECTIONAL)."},{"location":"trackers/crossingsCounter/#destroy","title":"destroy","text":"<p>void destroy()</p> <p>Cleans up device memory.</p>"},{"location":"trackers/crossingsCounter/#reset","title":"reset","text":"<p>void reset()</p> <p>Resets the crossing counts to zero.</p>"},{"location":"trackers/layerLogger/","title":"layerLogger","text":"<p>template&lt;typename Layer&gt; class layerLogger</p> <p>Asynchronous logger that records layer states and inputs to CSV files.</p> <code>Layer</code> Layer type exposing state_tuple_type and input buffers."},{"location":"trackers/layerLogger/#functions","title":"Functions","text":"Name Description layerLogger Constructs the logger with simulation and IO streams. start Allocates buffers and opens CSV outputs. write Schedules a logging operation for the given simulation step. stop Flushes and closes files, ensuring pending copies finish."},{"location":"trackers/layerLogger/#function-details","title":"Function Details","text":""},{"location":"trackers/layerLogger/#layerlogger_1","title":"layerLogger","text":"<p>layerLogger(Layer&amp; layer, cudaStream_t streamSim, cudaStream_t streamIO, const std::string&amp; name)</p> <p>Constructs the logger with simulation and IO streams.</p> <code>layer</code> Layer to observe. <code>streamSim</code> CUDA stream used by the simulation. <code>streamIO</code> CUDA stream used for IO operations. <code>name</code> Base file name for generated CSVs."},{"location":"trackers/layerLogger/#start","title":"start","text":"<p>void start()</p> <p>Allocates buffers and opens CSV outputs.</p>"},{"location":"trackers/layerLogger/#stop","title":"stop","text":"<p>void stop()</p> <p>Flushes and closes files, ensuring pending copies finish.</p>"},{"location":"trackers/layerLogger/#write","title":"write","text":"<p>void write(int step)</p> <p>Schedules a logging operation for the given simulation step.</p> <code>step</code> Current simulation step index."},{"location":"trackers/layerLogger_sync/","title":"layerLogger_sync","text":"<p>template&lt;typename Layer&gt; class layerLogger_sync</p> <p>Synchronous logger optionally buffering data before writing to CSV.</p> <code>Layer</code> Layer type exposing state_tuple_type and input buffers."},{"location":"trackers/layerLogger_sync/#functions","title":"Functions","text":"Name Description layerLogger_sync Constructs the synchronous logger. start Opens output streams and prepares internal buffers. write Copies current layer state and writes or buffers it. stop Flushes buffered data and closes files."},{"location":"trackers/layerLogger_sync/#function-details","title":"Function Details","text":""},{"location":"trackers/layerLogger_sync/#layerlogger_sync_1","title":"layerLogger_sync","text":"<p>layerLogger_sync(Layer&amp; layer, const std::string&amp; name, Mode mode = ACCUMULATE_AND_FINALIZE)</p> <p>Constructs the synchronous logger.</p> <code>layer</code> Layer to observe. <code>name</code> Base filename for CSV outputs. <code>mode</code> Logging mode controlling buffering behavior."},{"location":"trackers/layerLogger_sync/#start","title":"start","text":"<p>void start()</p> <p>Opens output streams and prepares internal buffers.</p>"},{"location":"trackers/layerLogger_sync/#stop","title":"stop","text":"<p>void stop()</p> <p>Flushes buffered data and closes files.</p>"},{"location":"trackers/layerLogger_sync/#write","title":"write","text":"<p>void write(int step)</p> <p>Copies current layer state and writes or buffers it.</p> <code>step</code> Current simulation step index."},{"location":"utilities/","title":"Utilities","text":"<p>Helper functions and utilities</p>"},{"location":"utilities/#functions","title":"Functions","text":"Name Description balanced3 Factorizes an integer into a balanced 3D lattice (a &lt;= b &lt;= c). load_device_vector_from_file Reads a device vector from a binary stream. print_device_vector Prints basic information about a device vector. print_nested_progress Renders two-level nested progress bars in-place. print_progress Renders a single-line progress bar. save_device_vector_to_file Writes a device vector to a binary stream."},{"location":"utilities/#function-details","title":"Function Details","text":""},{"location":"utilities/#balanced3","title":"balanced3","text":"<p>inline std::tuple&lt;int, int, int&gt; balanced3(int N)</p> <p>Factorizes an integer into a balanced 3D lattice (a &lt;= b &lt;= c).</p> <code>N</code> Number of elements to distribute. Return Tuple of three factors whose product equals N."},{"location":"utilities/#load_device_vector_from_file","title":"load_device_vector_from_file","text":"<p>bool load_device_vector_from_file(std::fstream&amp; fs, thrust::device_vector&lt;float&gt;&amp; vec)</p> <p>Reads a device vector from a binary stream.</p> <code>fs</code> Input file stream. <code>vec</code> Destination vector populated from disk. Return true on success."},{"location":"utilities/#print_device_vector","title":"print_device_vector","text":"<p>void print_device_vector(const thrust::device_vector&lt;float&gt;&amp; vec, const string&amp; name)</p> <p>Prints basic information about a device vector.</p> <code>vec</code> Vector to inspect. <code>name</code> Label used in the output."},{"location":"utilities/#print_nested_progress","title":"print_nested_progress","text":"<p>inline void print_nested_progress( int i_current, int i_total, int j_current, int j_total, int width = 30, const std::string&amp; outer_text = \"Overall\", const std::string&amp; inner_text = \"Batch\" )</p> <p>Renders two-level nested progress bars in-place.</p> <code>i_current</code> Outer loop current iteration. <code>i_total</code> Outer loop total iterations. <code>j_current</code> Inner loop current iteration. <code>j_total</code> Inner loop total iterations. <code>width</code> Width of each bar in characters. <code>outer_text</code> Label for the outer bar. <code>inner_text</code> Label for the inner bar."},{"location":"utilities/#print_progress","title":"print_progress","text":"<p>inline void print_progress(int current, int total, int width = 50)</p> <p>Renders a single-line progress bar.</p> <code>current</code> Current progress count. <code>total</code> Total count representing 100%. <code>width</code> Width of the bar in characters."},{"location":"utilities/#save_device_vector_to_file","title":"save_device_vector_to_file","text":"<p>bool save_device_vector_to_file(std::fstream&amp; fs, const thrust::device_vector&lt;float&gt;&amp; vec)</p> <p>Writes a device vector to a binary stream.</p> <code>fs</code> Output file stream. <code>vec</code> Vector to serialize. Return true on success."}]}